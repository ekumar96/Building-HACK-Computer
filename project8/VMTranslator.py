# -*- coding: utf-8 -*-
"""VM_Translator.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11jFb7W8Ab6z0gneZv62emK_upkFBhXgU
    - added few lines when translating from .ipynb -> .py, these are marked with #.py added line

# VM Translator for nand2tetris, Project 7/8

Purpose: Convert VM files (using Stack data structures) to Assembly files (Hack)
More complete implementation of VMTranslator made for project 7

To use, type "python3 VMTranslator.py dir/folder/" where dir/folder/ is a directory containing .vm files 
    or type "python3 VMTranslator.py file.vm" where file is a .vm file


#File Preprocessing 
In this section, we:
- upload the entire file, then open it as a string
- remove comments and blank lines, and remove inline comments
- turn the long string into a list of strings, with each list item being a line in VM
"""

#.py added line (import sys)
import re
import sys
import os

def getFileString(fileName):
  with open(fileName, 'r') as reader:
      # Read & print the entire file
      vmString = reader.read()
      #print(asmString)
  return vmString

def writeStringFile(fileName, asmStr):
  with open(fileName+'.asm', 'w') as fileW:
      # Read & print the entire file
      n = fileW.write(asmStr)
      #print(asmString)
  return

# Preprocess file and remove all comments/blank lines

def removeComments(string):
    string = re.sub(re.compile("/\*.*?\*/",re.DOTALL ) ,"" ,string) # remove all occurrences streamed comments (/*COMMENT */) from string
    string = re.sub(re.compile("//.*?$" ) ,"" ,string) # remove all occurrence single-line comments (//COMMENT\n ) from string
    return string

"""#Line Parsing
Next, with the input being a single line, we parse each line. To parse, we determine:
- the type of command (push, pop, arithmetic, etc.)
- the first argument of the command
- the second argument of the command, if any
"""

#Parses single line of VM File

def parseLine(vmLine):
  commandType, argLine = cmdType(vmLine)
  arg1 = "null"
  arg2 = "null"
  if commandType != 0 and commandType != 8: #if return command or unrecognizable command, does not proceed
    arg1 = firstArg(argLine)
    #only checks for second argument if push, pop, function, or call
    if commandType == 1 or commandType == 2 or commandType == 6 or commandType == 7:
      arg2 = secondArg(argLine)
  return commandType, arg1, arg2


def cmdType(vmLine): #figures out command type (arithmetic, push, pop, etc.)
  if vmLine.startswith('push'):
    argLine = re.sub("push ", "", vmLine) #removes push so only arguments left in string
    return 1, argLine
  elif vmLine.startswith('pop'):
    argLine = re.sub("pop ", "", vmLine) 
    return 2, argLine
  elif vmLine.startswith('label'):
    argLine = re.sub("label ", "", vmLine) 
    return 3, argLine
  elif vmLine.startswith('goto'):
    argLine = re.sub("goto ", "", vmLine) 
    return 4, argLine
  elif vmLine.startswith('if-goto'):
    argLine = re.sub("if-goto ", "", vmLine) 
    return 5, argLine
  elif vmLine.startswith('function'):
    argLine = re.sub("function ", "", vmLine) 
    return 6, argLine
  elif vmLine.startswith('call'):
    argLine = re.sub("call ", "", vmLine) 
    return 7, argLine
  elif vmLine.startswith('return'): #not implemented properly yet
    return 8, vmLine
  elif vmLine.startswith('add') or vmLine.startswith('sub') or vmLine.startswith('neg') or vmLine.startswith('eq') or vmLine.startswith('gt') or vmLine.startswith('lt') or vmLine.startswith('and') or vmLine.startswith('or') or vmLine.startswith('not'):
    return 9, vmLine
  else:
    return 0

def firstArg(argLine): #gets first argument (first word) of command 
  arg1 = argLine.split()[0]
  return arg1

def secondArg(argLine): #gets second argument (last word) of command
  arg2 = argLine.split()[-1]
  return arg2

"""#Code Writing in Assembly
Next, based on each command type and arguments, we must:
- write how to translate code to Assembly for push/pop in relation to the 8 memory segments 
 - (constant, local, argument, this, that, static, temp, pointer)
- write code in Assembly for arithmetic VM commands 
 - (add, sub, and, or, not, neg, eq, gt, lt)
"""

#writes code in assembly for single line of VM File
def codeWriter(vmLine, commandType, arg1, arg2, labelNum, fileName, callNum, functionName):
  asmLines = []
  #provides line in VM for readability and to help debug
  commentStr = "// " + vmLine 
  asmLines.append(commentStr)
  if commandType == 1 or commandType == 2:
    asmLines.extend(writePushPop(commandType, arg1, arg2, fileName))
  elif commandType == 3:
    asmLines.extend(writeLabel(arg1, functionName))
  elif commandType == 4:
    asmLines.extend(writeGoto(arg1, functionName))
  elif commandType == 5:
    asmLines.extend(writeIf(arg1, functionName))
  elif commandType == 6:
    functionName = arg1
    asmLines.extend(writeFunction(arg1, arg2))
    #callNum = 0
  elif commandType == 7:
    asmLines.extend(writeCall(arg1, arg2, callNum))
    callNum = callNum+1
  elif commandType == 8:
    asmLines.extend(writeReturn())
  elif commandType == 9: 
    nextLines, labelNum = writeArithmetic(arg1, labelNum)
    asmLines.extend(nextLines)
  return asmLines, labelNum, callNum, functionName

def writeFunction(fxnName, numVars):
  #to translate function, simply Add label for function declaration, and push 0 numVars times (initialize local)
  asmLines = []
  asmLines.extend(["("+fxnName+")"])
  for x in range(int(numVars)):
    asmLines.extend(writePushPop(1, "constant", "0", "null"))
  return asmLines

def writeReturn():
  #to translate return- must get the address to return to, place return value in ARG 0 (top of stack), restore old state (that this arg local), finally go to return address
  asmLines = []
  asmLines.extend(["@LCL   //endframe (R15) = LCL", "D=M", "@R15", "M=D"])
  asmLines.extend(["@5     //retAddr (R14) = *(endframe-5)", "D=D-A", "A=D", "D=M","@R14","M=D"])
  asmLines.extend(["@SP    //D=pop()", "M=M-1", "@SP", "A=M","D=M"])
  asmLines.extend(["@ARG   //*ARG=D", "A=M", "M=D"])
  asmLines.extend(["@ARG   //SP = ARG+1", "D=M+1", "@SP", "M=D"])
  asmLines.extend(["@R15   //THAT = *(endframe-1)", "D=M", "@1", "D=D-A", "A=D", "D=M", "@THAT", "M=D"])
  asmLines.extend(["@R15   //THIS = *(endframe-2)", "D=M", "@2", "D=D-A", "A=D", "D=M", "@THIS", "M=D"])
  asmLines.extend(["@R15   //ARG = *(endframe-3)", "D=M", "@3", "D=D-A", "A=D", "D=M", "@ARG", "M=D"])
  asmLines.extend(["@R15   //LCL = *(endframe-4)", "D=M", "@4", "D=D-A", "A=D", "D=M", "@LCL", "M=D"])
  asmLines.extend(["@R14   //goto retAddr", "A=M", "0;JMP"])
  return asmLines

def writeCall(fxnName, numArgs, callNum):
  #when calling a fxn, must get an address to return to after the call, push this and state (local arg this that) to stack, set new arg(part of old arg) and new locals, then jump to function that youre calling
  asmLines = []
  asmLines.extend(["@"+fxnName+"$ret."+str(callNum)+"    //push returnAddr", "D=A", "@SP", "A=M", "M=D"])
  asmLines.extend(["@SP    //SP++", "M=M+1"])
  asmLines.extend(["@LCL    //push LCL", "D=M", "@SP", "A=M", "M=D"])
  asmLines.extend(["@SP    //SP++", "M=M+1"])
  asmLines.extend(["@ARG    //push ARG", "D=M", "@SP", "A=M", "M=D"])
  asmLines.extend(["@SP    //SP++", "M=M+1"])
  asmLines.extend(["@THIS    //push THIS", "D=M", "@SP", "A=M", "M=D"])
  asmLines.extend(["@SP    //SP++", "M=M+1"])
  asmLines.extend(["@THAT    //push THAT", "D=M", "@SP", "A=M", "M=D"])
  asmLines.extend(["@SP    //SP++", "M=M+1"])
  asmLines.extend(["@SP    //ARG = SP-5-num_args", "D=M", "@5", "D=D-A", "@"+str(numArgs), "D=D-A", "@ARG", "M=D"])
  asmLines.extend(["@SP    //LCL=SP", "D=M", "@LCL", "M=D"])
  asmLines.extend(["@"+fxnName, "0;JMP"])
  asmLines.extend(["("+fxnName+"$ret."+str(callNum)+")"])
  return asmLines

def writeLabel(label, fxn):
  #can simply create label
  asmLines = []
  asmLines.extend(["("+fxn+"$"+label+")"])
  return asmLines

def writeGoto(label, fxn):
  #unconditional go to a label
  asmLines = []
  asmLines.extend(["@"+fxn+"$"+label+"    //unconditional jump", "0;JMP"])
  return asmLines

def writeIf(label, fxn):
  #if the top of the stack is true, pop it and go to the label
  asmLines = []
  asmLines.extend(["@SP    //SP--", "M=M-1"])
  #the top of the stack would be =0 if false, so if NOT 0, must be true, so will jump
  asmLines.extend(["@SP    //D=RAM[SP]", "A=M", "D=M"]) 
  asmLines.extend(["@"+fxn+"$"+label+"    //conditional jump", "D;JNE"])
  return asmLines

#writes lines in assembly if line was push or pop
def writePushPop(commandType, segment, index, fileName):
  asmLines = []
  argkey = {
    "local":"LCL",
    "argument":"ARG",
    "this":"THIS",
    "that":"THAT",
    "0":"THIS",
    "1":"THAT"
  }
  if segment == "constant":
    #if constant, only need to worry about push (wont pop to here)
    asmLines.extend(["@"+index+"    //D="+index, "D=A"])
    asmLines.extend(["@SP    //*SP=D", "A=M", "M=D"])
    asmLines.extend(["@SP    //SP++", "M=M+1"])
  elif segment == "local" or segment == "argument" or segment == "this" or segment == "that":
    #for local/arg/this/that, treated same - simply need to look at base address+i, and put value there for pop or take value for push
    segPtrLine = "@"+argkey[segment]+"   //R15 = addr = "+segment+" base address+"+index
    asmLines.extend([segPtrLine, "D=M", "@"+index, "D=D+A", "@R15", "M=D"])
    if commandType == 1: #for push
      asmLines.extend(["A=D    //D=RAM[addr]", "D=M", "@SP    //SP=D", "A=M", "M=D"])
      asmLines.extend(["@SP    //SP++", "M=M+1"])
    elif commandType == 2: #for pop
      asmLines.extend(["@SP    //SP--", "M=M-1"])
      asmLines.extend(["@SP    //D=RAM[SP]", "A=M", "D=M", "@R15   //RAM[addr]=D", "A=M", "M=D"])
  elif segment == "static":
    #for static - may need to create new variable if push, or take value for pop
    segPtrLine = "@"+fileName+"."+index+"   //accessing static variable"
    if commandType == 1:
      asmLines.extend([segPtrLine, "D=M"])
      asmLines.extend(["@SP    //SP=D", "A=M", "M=D"])
      asmLines.extend(["@SP    //SP++", "M=M+1"])
    elif commandType == 2:
      asmLines.extend(["@SP    //SP--", "M=M-1"])
      asmLines.extend(["@SP    //D=RAM[SP]", "A=M", "D=M", segPtrLine, "M=D"])
  elif segment == "temp":
    #temp is same as local/arg/this/that, but base address is given (R5-R12)
    segPtrLine = "@5   //R15 = addr = temp base address(5)+"+index
    asmLines.extend([segPtrLine, "D=A", "@"+index, "D=D+A", "@R15", "M=D"])
    if commandType == 1:
      asmLines.extend(["A=D    //D=RAM[addr]", "D=M", "@SP    //SP=D", "A=M", "M=D"])
      asmLines.extend(["@SP    //SP++", "M=M+1"])
    elif commandType == 2:
      asmLines.extend(["@SP    //SP--", "M=M-1"])
      asmLines.extend(["@SP    //D=RAM[SP]", "A=M", "D=M", "@R15   //RAM[addr]=D", "A=M", "M=D"])
  elif segment == "pointer":
    #for pointer, accessing pointer should lead to access of this/that - eg. push this 0: *SP = RAM[RAM[3]] vs. push pointer 0: *SP = RAM[3]
    if commandType == 1:
      asmLines.extend(["@"+argkey[index]+"  //*SP=THIS/THAT", "D=M", "@SP    //SP=D", "A=M", "M=D"])
      asmLines.extend(["@SP    //SP++", "M=M+1"])
    elif commandType == 2:
      asmLines.extend(["@SP    //SP--", "M=M-1"])
      asmLines.extend(["@SP    //THIS/THAT = *SP", "A=M", "D=M", "@"+argkey[index], "M=D"])
  return asmLines

#writes lines in assembly if line was arithmetic 
def writeArithmetic(operation, labelNum):
  asmLines = []
  arithKey = {
      "add": "+",
      "sub": "-",
      "and": "&",
      "or": "|",
      "not":"!",
      "neg":"-",
      "eq":"JEQ",
      "gt":"JGT",
      "lt":"JLT"
  }
  if operation == "add" or operation == "sub" or operation =="and" or operation=="or":
    #for add/sub/and/or, simply need to pop off top two operands, perform function, then push result back on stack
    #note: to understand what assembly commands are doing, look at //comments in strings
    asmLines.extend(["@SP    //SP--", "M=M-1"]) 
    asmLines.extend(["@SP    //y=*SP", "A=M", "D=M"]) 
    asmLines.extend(["@SP    //SP--", "M=M-1"])
    asmLines.extend(["@SP    //*SP = x"+arithKey[operation]+"y", "A=M", "M=M"+arithKey[operation]+"D"])
    asmLines.extend(["@SP    //SP++", "M=M+1"])
  elif operation == "not" or operation == "neg":
    #for neg/negation, simply need to do fxn on top of stack
    asmLines.extend(["@SP    //SP--", "M=M-1"])
    asmLines.extend(["@SP    //y=*SP", "A=M", "M="+arithKey[operation]+"M"])
    asmLines.extend(["@SP    //SP++", "M=M+1"])
  elif operation == "eq" or operation == "gt" or operation == "lt":
    #for returning bool values, need to have more complex control, with labels and JMP commands
    asmLines.extend(["@SP    //SP--", "M=M-1"])
    asmLines.extend(["@SP    //y=*SP", "A=M", "D=M"])
    asmLines.extend(["@SP    //SP--", "M=M-1"])
    asmLines.extend(["@SP    //D=x-y", "A=M", "D=M-D"]) #D=0 if eq, D<0 if lt, D>0 if gt"
    asmLines.extend(["@LOGISTIC_TRUE"+str(labelNum)+" //jump if true", "D;"+arithKey[operation]]) #need to enumerate labels so every single one is unique
    asmLines.extend(["@SP    //*SP=false", "A=M", "M=0", "@JUMPTOEND"+str(labelNum)+"", "0;JMP"])
    asmLines.extend(["(LOGISTIC_TRUE"+str(labelNum)+")//*SP=true", "@SP", "A=M", "M=-1", "(JUMPTOEND"+str(labelNum)+")"])
    asmLines.extend(["@SP    //SP++", "M=M+1"])
    labelNum=labelNum+1
  return asmLines, labelNum

"""# Main function
Finally, we will call the parser and the codewriter for every line in VM to translate it to the proper lines in Assembly, then output these lines into a file
"""
  #main that calls parser and codewriter for every line of file
  #outputs into other file .asm
def main():
  #.py added 5 lines to get arguments when calling python3 in terminal, then removing .vm, then getting only file name
  args = sys.argv[1:] 
  inputFilePath = args[0] 

  #inputFilePath = inputFilePath[:-3]

  files = []
  asmLines = []
  labelNum = 0
  callNum= 0
  if inputFilePath[-3:] == ".vm":
    fileName = inputFilePath.split('/')[-1]
    files.append(fileName)
    dirPath = '/'.join(inputFilePath.split('/')[:-1])+'/'
    outputName = dirPath+fileName[:-3]
  else:
    outputName = inputFilePath+'/'+inputFilePath #+ inputFilePath.split('/')[-2]
    dirPath = inputFilePath
    vmFiles = [f for f in os.listdir(dirPath) if f.endswith('.vm')]
    files.extend(vmFiles)
    if(len(vmFiles) > 1):
      #if dealing with directory, need to add some initializing statements to boot up
      asmLines.extend(["@256    //SP=256", "D=A", "@SP", "M=D"])
      asmLines.extend(writeCall("Sys.init", 0, 0))

  for file in files:
    fileName = file[:-3]
    fileString = getFileString(dirPath+'/'+file)
    #print(fileString)
    lineList = fileString.split('\n')
    #print(lineList)
    rawlines = []


    for line in lineList:
      #if (not line.startswith('/')) and (line):
        #print(line) <- doesnt deal with inline comments
      cleanedLine = removeComments(line)
      if(cleanedLine): #if not empty line
        rawlines.append(cleanedLine)

    
    #junkstr = '\n'.join(rawlines)
    #print(junkstr)
    #print("the outputFile name:" + outputName)

    functionName = ""
    for line in rawlines:
      commandType, arg1, arg2 = parseLine(line)
      nextLines, labelNum, callNum, functionName = codeWriter(line, commandType, arg1, arg2, labelNum, fileName, callNum, functionName)
      asmLines.extend(nextLines)
      asmLines.append('\n')

  asmStr = '\n'.join(asmLines)
  #print(asmStr)
  writeStringFile(outputName, asmStr)

#.py added lines to call main
if __name__ == "__main__":
    main()

