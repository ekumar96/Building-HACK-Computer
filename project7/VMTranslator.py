# -*- coding: utf-8 -*-
"""VM_Translator.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11jFb7W8Ab6z0gneZv62emK_upkFBhXgU
    - added few lines when translating from .ipynb -> .py, these are marked with #.py added line

# VM Translator for nand2tetris, Project 7

Purpose: convert VM files to Assembly files

#File Preprocessing 
In this section, we:
- upload the entire file, then open it as a string
- remove comments and blank lines, and remove inline comments
- turn the long string into a list of strings, with each list item being a line in VM
"""

#.py added line (import sys)
import re
import sys

def getFileString(fileName):
  with open(fileName+'.vm', 'r') as reader:
      # Read & print the entire file
      vmString = reader.read()
      #print(asmString)
  return vmString

def writeStringFile(fileName, asmStr):
  with open(fileName+'.asm', 'w') as fileW:
      # Read & print the entire file
      n = fileW.write(asmStr)
      #print(asmString)
  return

# Preprocess file and remove all comments/blank lines

def removeComments(string):
    string = re.sub(re.compile("/\*.*?\*/",re.DOTALL ) ,"" ,string) # remove all occurrences streamed comments (/*COMMENT */) from string
    string = re.sub(re.compile("//.*?$" ) ,"" ,string) # remove all occurrence single-line comments (//COMMENT\n ) from string
    return string


"""#Line Parsing
Next, with the input being a single line, we parse each line. To parse, we determine:
- the type of command (push, pop, arithmetic, etc.)
- the first argument of the command
- the second argument of the command, if any
"""

#Parses single line of VM File

def parseLine(vmLine):
  commandType, argLine = cmdType(vmLine)
  arg1 = "null"
  arg2 = "null"
  if commandType != 0 and commandType != 8: #if return command or unrecognizable command, does not proceed
    arg1 = firstArg(argLine)
    #only checks for second argument if push, pop, function, or call
    if commandType == 1 or commandType == 2 or commandType == 6 or commandType == 7:
      arg2 = secondArg(argLine)
  return commandType, arg1, arg2


def cmdType(vmLine): #figures out command type (arithmetic, push, pop, etc.)
  if vmLine.startswith('push'):
    argLine = re.sub("push ", "", vmLine) #removes push so only arguments left in string
    return 1, argLine
  elif vmLine.startswith('pop'):
    argLine = re.sub("pop ", "", vmLine) 
    return 2, argLine
  elif vmLine.startswith('label'): #not implemented properly yet
    return 3, vmLine
  elif vmLine.startswith('goto'): #not implemented properly yet
    return 4, vmLine
  elif vmLine.startswith('if-goto'): #not implemented properly yet
    return 5, vmLine
  elif vmLine.startswith('function'): #not implemented properly yet
    return 6, vmLine
  elif vmLine.startswith('call'): #not implemented properly yet
    return 7, vmLine
  elif vmLine.startswith('return'): #not implemented properly yet
    return 8, vmLine
  elif vmLine.startswith('add') or vmLine.startswith('sub') or vmLine.startswith('neg') or vmLine.startswith('eq') or vmLine.startswith('gt') or vmLine.startswith('lt') or vmLine.startswith('and') or vmLine.startswith('or') or vmLine.startswith('not'):
    return 9, vmLine
  else:
    return 0

def firstArg(argLine): #gets first argument (first word) of command 
  arg1 = argLine.split()[0]
  return arg1

def secondArg(argLine): #gets second argument (last word) of command
  arg2 = argLine.split()[-1]
  return arg2

"""#Code Writing in Assembly
Next, based on each command type and arguments, we must:
- write how to translate code to Assembly for push/pop in relation to the 8 memory segments 
 - (constant, local, argument, this, that, static, temp, pointer)
- write code in Assembly for arithmetic VM commands 
 - (add, sub, and, or, not, neg, eq, gt, lt)
"""

#writes code in assembly for single line of VM File
def codeWriter(vmLine, commandType, arg1, arg2, labelNum, fileName):
  asmLines = []
  #provides line in VM for readability and to help debug
  commentStr = "// " + vmLine 
  asmLines.append(commentStr)
  if commandType == 9: 
    nextLines, labelNum = writeArithmetic(arg1, labelNum)
    asmLines.extend(nextLines)
  else:
    asmLines.extend(writePushPop(commandType, arg1, arg2, fileName))
  return asmLines, labelNum

#writes lines in assembly if line was push or pop
def writePushPop(commandType, arg1, arg2, fileName):
  asmLines = []
  argkey = {
    "local":"LCL",
    "argument":"ARG",
    "this":"THIS",
    "that":"THAT",
    "0":"THIS",
    "1":"THAT"
  }
  if arg1 == "constant":
    #if constant, only need to worry about push (wont pop to here)
    asmLines.extend(["@"+arg2+"    //D="+arg2, "D=A"])
    asmLines.extend(["@SP    //*SP=D", "A=M", "M=D", "@SP    //SP++", "M=M+1"])
  elif arg1 == "local" or arg1 == "argument" or arg1 == "this" or arg1 == "that":
    #for local/arg/this/that, treated same - simply need to look at base address+i, and put value there for pop or take value for push
    segPtrLine = "@"+argkey[arg1]+"   //R15 = addr = "+arg1+" base address+"+arg2
    asmLines.extend([segPtrLine, "D=M", "@"+arg2, "D=D+A", "@R15", "M=D"])
    if commandType == 1:
      asmLines.extend(["A=D    //D=RAM[addr]", "D=M", "@SP    //SP=D", "A=M", "M=D"])
      asmLines.extend(["@SP    //SP++", "M=M+1"])
    elif commandType == 2:
      asmLines.extend(["@SP    //SP--", "M=M-1"])
      asmLines.extend(["@SP    //D=RAM[SP]", "A=M", "D=M", "@R15   //RAM[addr]=D", "A=M", "M=D"])
  elif arg1 == "static":
    #for static - may need to create new variable if push, or take value for pop
    segPtrLine = "@"+fileName+"."+arg2+"   //accessing static variable"
    if commandType == 1:
      asmLines.extend([segPtrLine, "D=M"])
      asmLines.extend(["@SP    //SP=D", "A=M", "M=D"])
      asmLines.extend(["@SP    //SP++", "M=M+1"])
    elif commandType == 2:
      asmLines.extend(["@SP    //SP--", "M=M-1"])
      asmLines.extend(["@SP    //D=RAM[SP]", "A=M", "D=M", segPtrLine, "M=D"])
  elif arg1 == "temp":
    #temp is same as local/arg/this/that, but base address is given (R5-R12)
    segPtrLine = "@5   //R15 = addr = "+arg1+" base address(5)+"+arg2
    asmLines.extend([segPtrLine, "D=A", "@"+arg2, "D=D+A", "@R15", "M=D"])
    if commandType == 1:
      asmLines.extend(["A=D    //D=RAM[addr]", "D=M", "@SP    //SP=D", "A=M", "M=D"])
      asmLines.extend(["@SP    //SP++", "M=M+1"])
    elif commandType == 2:
      asmLines.extend(["@SP    //SP--", "M=M-1"])
      asmLines.extend(["@SP    //D=RAM[SP]", "A=M", "D=M", "@R15   //RAM[addr]=D", "A=M", "M=D"])
  elif arg1 == "pointer":
    #for pointer, accessing pointer should lead to access of this/that - eg. push this 0: *SP = RAM[RAM[3]] vs. push pointer 0: *SP = RAM[3]
    if commandType == 1:
      asmLines.extend(["@"+argkey[arg2]+"  //*SP=THIS/THAT", "D=M", "@SP    //SP=D", "A=M", "M=D"])
      asmLines.extend(["@SP    //SP++", "M=M+1"])
    elif commandType == 2:
      asmLines.extend(["@SP    //SP--", "M=M-1"])
      asmLines.extend(["@SP    //THIS/THAT = *SP", "A=M", "D=M", "@"+argkey[arg2], "M=D"])
  return asmLines
  
#writes lines in assembly if line was arithmetic 
def writeArithmetic(arg1, labelNum):
  asmLines = []
  arithKey = {
      "add": "+",
      "sub": "-",
      "and": "&",
      "or": "|",
      "not":"!",
      "neg":"-",
      "eq":"JEQ",
      "gt":"JGT",
      "lt":"JLT"
  }
  if arg1 == "add" or arg1 == "sub" or arg1 =="and" or arg1=="or":
    #for add/sub/and/or, simply need to pop off top two operands, perform function, then push result back on stack
    #note: to understand what assembly commands are doing, look at //comments in strings
    asmLines.extend(["@SP    //SP--", "M=M-1"]) 
    asmLines.extend(["@SP    //y=*SP", "A=M", "D=M"]) 
    asmLines.extend(["@SP    //SP--", "M=M-1"])
    asmLines.extend(["@SP    //*SP = x"+arithKey[arg1]+"y", "A=M", "M=M"+arithKey[arg1]+"D"])
    asmLines.extend(["@SP    //SP++", "M=M+1"])
  elif arg1 == "not" or arg1 == "neg":
    #for neg/negation, simply need to do fxn on top of stack
    asmLines.extend(["@SP    //SP--", "M=M-1"])
    asmLines.extend(["@SP    //y=*SP", "A=M", "M="+arithKey[arg1]+"M"])
    asmLines.extend(["@SP    //SP++", "M=M+1"])
  elif arg1 == "eq" or arg1 == "gt" or arg1 == "lt":
    #for returning bool values, need to have more complex control, with labels and JMP commands
    asmLines.extend(["@SP    //SP--", "M=M-1"])
    asmLines.extend(["@SP    //y=*SP", "A=M", "D=M"])
    asmLines.extend(["@SP    //SP--", "M=M-1"])
    asmLines.extend(["@SP    //D=x-y", "A=M", "D=M-D"]) #D=0 if eq, D<0 if lt, D>0 if gt"
    asmLines.extend(["@LOGISTIC_TRUE"+str(labelNum)+" //jump if true", "D;"+arithKey[arg1]]) #need to enumerate labels so every single one is unique
    asmLines.extend(["@SP    //*SP=false", "A=M", "M=0", "@JUMPTOEND"+str(labelNum)+"", "0;JMP"])
    asmLines.extend(["(LOGISTIC_TRUE"+str(labelNum)+")//*SP=true", "@SP", "A=M", "M=-1", "(JUMPTOEND"+str(labelNum)+")"])
    asmLines.extend(["@SP    //SP++", "M=M+1"])
    labelNum=labelNum+1
  return asmLines, labelNum

"""# Main function
Finally, we will call the parser and the codewriter for every line in VM to translate it to the proper lines in Assembly, then output these lines into a file
"""
def main():
  #.py added 5 lines to get arguments when calling python3 in terminal, then removing .vm, then getting only file name
    args = sys.argv[1:] 
    inputFilePath = args[0] 

    #removing filePath .vm
    if inputFilePath[-3:] == ".vm":
      inputFilePath = inputFilePath[:-3]

    fileName = inputFilePath.split('/')[-1]

    fileString = getFileString(inputFilePath)
    #print(fileString)

    lineList = fileString.split('\n')
    #print(lineList)
    rawlines = []

    for line in lineList:
      #if (not line.startswith('/')) and (line):
        #print(line) <- doesnt deal with inline comments
      cleanedLine = removeComments(line)
      if(cleanedLine): #if not empty line
        rawlines.append(cleanedLine)

    #print(rawlines)
    #main that calls parser and codewriter for every line of file
    #outputs into other file .asm
    asmLines = []
    labelNum = 0
    for line in rawlines:
      commandType, arg1, arg2 = parseLine(line)
      nextLines, labelNum = codeWriter(line, commandType, arg1, arg2, labelNum, fileName)
      asmLines.extend(nextLines)
      asmLines.append('\n')

    asmStr = '\n'.join(asmLines)
    #print(asmStr)
    writeStringFile(inputFilePath, asmStr)

#.py added lines to call main
if __name__ == "__main__":
    main()
